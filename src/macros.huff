
// === define where we'll store VM private things

// will store the pointer at mem 0, and correct all memory writes
#define constant EXEC_POINTER_MSLOT = 0x0



// increment the execution pointer location by one byte
#define macro INCREMENT_EXEC_PTR() = takes(0) returns (0) {
    0x1
    INCREMENT_EXEC_PTR_N()
}

// increment the execution pointer location by the amount given on stack
#define macro INCREMENT_EXEC_PTR_N() = takes(1) returns (0) {
    // load current
    [EXEC_POINTER_MSLOT] mload
    // add with value on stack
    add
    // and store it back
    [EXEC_POINTER_MSLOT] mstore
}


// pushes data that has the given size
#define macro PICK_DATA() = takes(1) returns (1) {
    // get 256 bits at execution pointer
    [EXEC_POINTER_MSLOT] mload  // => [execPtr, n]
    dup1   // => [execPtr, execPtr, n]
    calldataload // => [256 bits of code, execPtr, n]

    dup3 // duplicate num of bytes => [n, code, execPtr, n]

    // will be shifted by: (32 - n)
    0x20 // => [0x20, n, code, execPtr, n]
    sub //  => [shiftBy in Bytes, code, execPtr, n]
    0x8 mul // => [shiftBy, code, execPtr, n]

    // truncate it
    shr //  => [ret, execPtr, n]

    // increment pointer
    swap2 // => [execPtr, n, ret]
    add // => [newExecPtr, ret]
    [EXEC_POINTER_MSLOT] mstore // => [ret]
}

/**
copy memory
takes: size source target
*/
#define macro MEM_COPY() = takes(3) returns (0) {

    memcpy_one:
    //  -> [size source target]
    // if nothing to copy, then return
    dup1 iszero memcpy_end jumpi

    // copy one word (might embed a bit of extra memory if size is not multiple of 0x20, but its ok)
    dup2 mload // => [data size source target]
    dup4 mstore // => [size source target]

    // decrement size by 0x20, but maxed to size (size might not be a multiple of 0x20)
    0x20 dup2 lt // is size lower than 0x20 ? => [isSmall, size, source, target]

    memcpy_end jumpi // jump to end if smaller => [size, source, target]

    // decrement count
    0x20 swap1 sub // => [new size, source, target]
    // increment source
    swap1 0x20 add swap1 // => [new size, new source, target]
    // increment target
    swap2 0x20 add swap2 // => [new size, new source, new target]

    // restart
    memcpy_one jump
    memcpy_end:
    pop pop pop
}


// top stack item is a memory location: adjust the top stack item to prevent writing exec pointer.
#define macro FIX_MEMOFFSET() = takes (1) returns (1) {
    // offsets all memory instructions to locate them at the start of memory allocated to host
    // => everything before will be owned by the VM, and innaccessible by the host.
    [HOST_MEMORY_START] add
}

// load the opcode corresponding to the execution pointer on stack
#define macro LOAD_OPCODE() = takes(1) returns (1) {
    calldataload // => [256 bits of code starting at execution pointer, ptr]

    // extract opcode from leftmost byte   => [opcode, ptr]
    0xF8 shr // F8 = 248 = 256 - 8
}


// get the host instruction at given pointer location, and advance pointer by one
// (nb: this is used both by CONTINUE() and by jump instruction)
#define macro GOTO_AND_ADVANCE() = takes (1) returns (1) {

    dup1 // => [ptr, ptr]
    LOAD_OPCODE() // => [opcode, ptr]

    // increment the exec pointer to the next byte
    //  ... equivalent to INCREMENT_EXEC_PTR(), but avoids an mload.
    swap1 // => [ptr, opcode]
    0x1 add// => [new ptr, opcode]
    [EXEC_POINTER_MSLOT] mstore // => [opcode]
}

#define macro CONTINUE() = takes(0) returns (1) {

    // load the instruction located at this execution pointer
    [EXEC_POINTER_MSLOT] mload

    GOTO_AND_ADVANCE() // => [opcode]


    // // console.log('opcode:')
    // 0x6f70636f64653a00000000000000000000000000000000000000000000000000
    // 0x0000000000000000000000000000000000000000000000000000000000000007
    // CONSOLE_LOG()
    // // console.log(opcode)
    // CONSOLE_LOG_UINT()

    // jump to the operation given on stack
    JUMP_TO_OPCODE()
}
